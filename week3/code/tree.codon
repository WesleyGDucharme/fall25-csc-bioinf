# Minimal tree primitives for UPGMA/NJ tests


class TreeNode:
    children: list[TreeNode]
    parent: Optional[TreeNode]
    index: Optional[int]
    distance: float

    def __init__(self, children = None,
                 distances = None, 
                 index: Optional[int] = None):
        # Public fields
        self.children = []
        self.parent = None
        self.index = index            # leaf iff not None
        self.distance = 0.0           # edge length to parent (root = 0)

        if children is not None:
            if index is not None:
                raise Exception("Leaf (index set) cannot have children")
            if distances is None:
                distances = [0.0] * len(children)
            if len(distances) != len(children):
                raise Exception("distances length must match children length")
            # attach children
            for child, d in zip(children, distances):
                if child.parent is not None:
                    raise Exception("Child already has a parent")
                child.parent = self
                # child's distance is distance to THIS node
                child.distance = float(d)
                self.children.append(child)

    # ---- convenience helpers often used in tests ----
    def get_indices(self):
        """Return list of leaf indices under this node (DFS order)."""
        out = []
        self._collect_indices(self, out)
        return out

    def _collect_indices(self, node, out):
        if node.index is not None and not node.children:
            out.append(node.index)
            return
        for ch in node.children:
            self._collect_indices(ch, out)

    def get_leaf_count(self):
        """Count leaves below this node."""
        cnt = 0
        stack = [self]
        while stack:
            n = stack.pop()
            if n.index is not None and not n.children:
                cnt += 1
            else:
                for c in n.children:
                    stack.append(c)
        return cnt

    def __hash__(self):
    # identity-based hashing (like Python's default)
        return id(self)

    def __hash__(self):
        # identity-based hashing (matches how we use nodes as keys)
        return id(self)

    def __eq__(self, other):
        # compare by identity so two different nodes with same content aren't equal
        return self is other

    def __ne__(self, other):
        return not self.__eq__(other)

    # ---- metrics on nodes ----
    def distance_to(self, other):
        """Metric distance along unique path to 'other'."""
        # Build path map for self (node -> (edge_count, metric_sum))
        amap_edges, amap_len = _path_to_root_maps(self)
        # Walk other up until LCA
        edges_b = 0
        len_b = 0.0
        cur = other
        while cur is not None:
            if cur in amap_edges:
                return float(float(amap_len[cur]) + len_b)
            # step up
            parent = cur.parent
            if parent is None:
                # reached root without meeting; trees differ?
                break
            edges_b += 1
            len_b += cur.distance
            cur = parent
        raise Exception("Nodes are not in the same tree")

    def copy(self):
        """Deep copy of this subtree (no shared objects)."""
        if not self.children:
            # leaf
            dup = TreeNode(index=self.index)
            dup.distance = self.distance
            return dup
        # internal
        new_children = []
        new_dists = []
        for ch in self.children:
            ch2 = ch.copy()
            new_children.append(ch2)
            new_dists.append(ch.distance)
        dup = TreeNode(new_children, new_dists, index=None)
        dup.distance = self.distance
        return dup

def _nw_strip_ws(s):
    # remove spaces/tabs/newlines for simpler parsing
    out = []
    for ch in s:
        if ch not in [' ', '\t', '\n', '\r']:
            out.append(ch)
    return "".join(out)

class _NWParser:
    def __init__(self, s):
        self.text = _nw_strip_ws(s)
        self.pos = 0

    def _peek(self):
        if self.pos >= len(self.text):
            return ''
        return self.text[self.pos]

    def _take(self):
        ch = self._peek()
        self.pos += 1
        return ch

    def _read_number(self):
        start = self.pos
        if self._peek() in ['+', '-']:
            self._take()
        has_digit = False
        while self._peek().isdigit():
            has_digit = True
            self._take()
        if self._peek() == '.':
            self._take()
            while self._peek().isdigit():
                has_digit = True
                self._take()
        if self._peek() in ['e', 'E']:
            self._take()
            if self._peek() in ['+', '-']:
                self._take()
            while self._peek().isdigit():
                has_digit = True
                self._take()
        if not has_digit:
            raise Exception("Expected number in branch length")
        return float(self.text[start:self.pos])

    def _read_label(self):
        start = self.pos
        while self.pos < len(self.text) and self.text[self.pos] not in [',', ')', ':', ';']:
            self.pos += 1
        return self.text[start:self.pos].strip()

    def _parse_subtree(self):
        # returns (TreeNode, edge_len_to_parent)
        if self._peek() == '(':
            self._take()  # '('
            children = []
            dists = []

            n, el = self._parse_subtree()
            children.append(n); dists.append(el)
            while self._peek() == ',':
                self._take()
                n, el = self._parse_subtree()
                children.append(n); dists.append(el)

            if self._peek() != ')':
                raise Exception("Expected ')'")
            self._take()  # ')'

            # optional internal name: ignore any token until a delimiter
            if self._peek() not in [':', ',', ')', ';', '']:
                _ = self._read_label()

            edge_len = 0.0
            if self._peek() == ':':
                self._take()
                edge_len = self._read_number()

            node = TreeNode(children, dists, index=None)
            return node, edge_len
        else:
            lbl = self._read_label()
            if lbl == "":
                raise Exception("Empty leaf label")

            # Require integer leaf labels (fits your test fixture)
            try:
                idx = int(lbl)
            except:
                raise Exception("Leaf label must be an integer")

            edge_len = 0.0
            if self._peek() == ':':
                self._take()
                edge_len = self._read_number()
            node = TreeNode(index=idx)
            return node, edge_len


class Tree:
    root: TreeNode
    leaves: list[TreeNode]
    def __init__(self, root):
        if root is None:
            raise Exception("Tree requires a root")
        self.root = root
        self.leaves = _collect_leaves(root)
        idxs = [lf.index for lf in self.leaves]
        if any(i is None for i in idxs):
            raise Exception("All leaves must have an index")
        idxs_sorted = sorted(idxs)
        for k, v in enumerate(idxs_sorted):
            if k != v:
                raise Exception("Leaf indices must be contiguous 0..n-1")
        self.leaves.sort(key=lambda x: x.index)

    def __len__(self):
        return len(self.leaves)

    def copy(self):
        return Tree(self.root.copy())

    def get_distance(self, i, j, topological=False):
        """Distance between leaves i and j.
        - metric (sum of edge lengths) if topological == False
        - number of edges if topological == True
        """
        a = self.leaves[i]
        b = self.leaves[j]

        if topological:
            return _topo_distance(a, b)

        # metric branch (unchanged; sum to LCA)
        a_edges, a_len = _path_to_root_maps(a)
        len_b = 0.0
        cur = b
        while cur is not None:
            if cur in a_edges:
                return float(float(a_len[cur]) + len_b)
            parent = cur.parent
            if parent is None:
                break
            len_b += cur.distance
            cur = parent
        raise Exception("Leaves not in same tree")


    def __eq__(self, other):
        if not isinstance(other, Tree):
            return False
        return _canon(self.root) == _canon(other.root)

    @staticmethod
    def from_newick(s, labels=None):
        p = _NWParser(s)
        node, _ = p._parse_subtree()
        if p._peek() == ';':
            p._take()
        return Tree(node)

# ---------- internal helpers ----------

def _collect_leaves(root):
    leaves = []
    stack = [root]
    while stack:
        n = stack.pop()
        if n.index is not None and not n.children:
            leaves.append(n)
        else:
            for c in n.children:
                stack.append(c)
    return leaves


def _path_to_root_maps(node):
    """Return (edges_map, len_map) from node to root."""
    edges_map = {}
    len_map = {}
    cur = node
    edges = 0
    length = 0.0
    while cur is not None:
        edges_map[cur] = edges
        len_map[cur] = float(length)
        parent = cur.parent
        if parent is None:
            break
        edges += 1
        length += float(cur.distance)
        cur = parent
    return edges_map, len_map


def _canon(node):
    """Order-insensitive canonical form including edge lengths."""
    if node.index is not None and not node.children:
        return f"L{node.index}"
    parts = []
    for ch in node.children:
        # include edge length with consistent rounding/format
        parts.append(f"{round(ch.distance, 12):.12f}:{_canon(ch)}")
    parts.sort()
    return "I[" + ",".join(parts) + "]"

# helper: count edges between two leaves
def _topo_distance(a, b):
    # steps from a to each ancestor
    seen = {}
    steps = 0
    x = a
    while x is not None:
        seen[x] = steps
        parent = x.parent
        if parent is None:
            break
        steps += 1
        x = parent

    # walk from b upward until we hit an ancestor of a
    steps_b = 0
    y = b
    while y is not None:
        if y in seen:
            # exact integer edge count
            return float(seen[y] + steps_b)  # keep get_distance return type == float
        parent = y.parent
        if parent is None:
            break
        steps_b += 1
        y = parent

    raise Exception("Leaves not in same tree")
