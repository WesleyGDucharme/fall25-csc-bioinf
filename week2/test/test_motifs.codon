# Codon tests for week2 motifs port
# Made using tests from test_motifs.py that are relevent to the 4 modules we are poritng for this weeks deliverable.


from unittest import TestCase
from math import isfinite

import sys
from python import os, io as pyio
sys.path.append("week2/code")

import __init__ as motifs_init
import matrix as motifs_matrix
import minimal as motifs_minimal
import thresholds as motifs_thresholds

# Helpers for building a tiny motif by hand

def make_toy_instances() -> list[str]:
    # All uppercase DNA; length = 4; simple, deterministic
    # Count columns (A,C,G,T):
    # pos0: A=4, C=0, G=0, T=0
    # pos1: A=0, C=4, G=0, T=0
    # pos2: A=0, C=1, G=3, T=0
    # pos3: A=0, C=1, G=0, T=3
    return ["ACGT", "ACGT", "AGGT", "ACCT"]

def expected_counts() -> list[dict[str,int]]:
    return [
        {"A":4, "C":0, "G":0, "T":0},
        {"A":0, "C":4, "G":0, "T":0},
        {"A":0, "C":1, "G":3, "T":0},
        {"A":0, "C":1, "G":0, "T":3},
    ]

def uniform_bg() -> dict[str, float]:
    return {"A":0.25, "C":0.25, "G":0.25, "T":0.25}


# Core Motif API (__init__)

class TestMotifCore(TestCase):
    def test_create_basic_properties(self):
        inst = make_toy_instances()
        m = motifs_init.create(instances=inst)  # expected upstream-style entry
        self.assertEqual(m.length, 4)
        self.assertEqual(m.alphabet, "ACGT")
        self.assertEqual(len(m.instances), len(inst))
        self.assertEqual(m.counts["A"][0], 4)
        self.assertEqual(m.counts["C"][1], 4)

    def test_consensus_and_rc(self):
        inst = make_toy_instances()
        m = motifs_init.create(instances=inst)
        # For our toy motif, consensus should be "ACGT"
        self.assertEqual(m.consensus, "ACGT")
        rc = m.reverse_complement()
        # Reverse complement of consensus "ACGT" is "ACGT" (palindromic across positions)
        self.assertEqual(rc.consensus, "ACGT")

    def test_degenerate_consensus_exists(self):
        inst = make_toy_instances()
        m = motifs_init.create(instances=inst)
        # Just ensure property/method works and returns a non-empty string
        deg = m.degenerate_consensus
        self.assertTrue(isinstance(deg, str))
        self.assertGreaterEqual(len(deg), 1)


# Matrix (counts→PWM→PSSM and scoring)

class TestMatrix(TestCase):
    def test_counts_pwm_pssm_shapes(self):
        inst = make_toy_instances()
        m = motifs_init.create(instances=inst)
        pwm = m.pwm(pseudocounts=0.0, background=uniform_bg())
        pssm = m.pssm(pseudocounts=0.0, background=uniform_bg())
        # Basic shape/keys checks
        self.assertEqual(sorted(pwm.keys()), ["A","C","G","T"])
        self.assertEqual(len(pwm["A"]), m.length)
        self.assertEqual(len(pssm["A"]), m.length)
        # All finite numbers for this deterministic case
        for base in ["A","C","G","T"]:
            for j in range(m.length):
                self.assertTrue(isfinite(pwm[base][j]))
                self.assertTrue(isfinite(pssm[base][j]))

    def test_pssm_expected_values_one_column(self):
        # Verify a specific columns log-odds against hand-computed targets
        # Column 0 counts: A=4, others=0; PWM probs (no pseudocounts) => A=1.0, C/G/T=0
        # PSSM (log odds, natural log by our convention):
        # A: ln(1.0 / 0.25) = ln(4)  1.38629436
        inst = make_toy_instances()
        m = motifs_init.create(instances=inst)
        pssm = m.pssm(pseudocounts=0.0, background=uniform_bg())
        self.assertAlmostEqual(pssm["A"][0], 1.38629436, places=6)
        # The zero-prob entries should be either very negative or a defined floor
        # Depending on your implementation, check they’re <= some negative bound.
        self.assertLessEqual(pssm["C"][0], -9.0)
        self.assertLessEqual(pssm["G"][0], -9.0)
        self.assertLessEqual(pssm["T"][0], -9.0)

    def test_sliding_window_scoring(self):
        # Use calculate()/score() over a short sequence and validate a few windows
        inst = make_toy_instances()
        m = motifs_init.create(instances=inst)
        pssm = m.pssm(pseudocounts=0.0, background=uniform_bg())
        seq = "TTACGTACCCGT"
        # Expecting a high score where the exact "ACGT" window appears
        # Finding all 4-mer windows and compute; assert peak near "ACGT"
        scores = motifs_matrix.calculate(pssm, seq)  # expect list[float] length len(seq)-L+1
        self.assertEqual(len(scores), len(seq) - m.length + 1)
        # The exact "ACGT" occurs at positions 2 ("ACGT") and 6 ("ACCC"? no), check peak at 2
        self.assertGreater(scores[2], 1.0)   # should be distinctly higher than mismatches
        # Mismatching window like "TTAC" at pos 0 should be low
        self.assertLess(scores[0], 0.0)


# Thresholds (FPR/FNR/"balanced")

class TestThresholds(TestCase):
    def _pssm_for_thresholds(self):
        inst = make_toy_instances()
        m = motifs_init.create(instances=inst)
        return m.pssm(pseudocounts=0.0, background=uniform_bg())

    def test_fpr_monotonic(self):
        pssm = self._pssm_for_thresholds()
        dist = motifs_thresholds.ScoreDistribution(pssm, background=uniform_bg(), precision=1000)
        t_1pct = dist.threshold_fpr(0.01)
        t_5pct = dist.threshold_fpr(0.05)
        # Allowing higher FPR should lower the threshold
        self.assertGreater(t_1pct, t_5pct)

    def test_fnr_monotonic(self):
        pssm = self._pssm_for_thresholds()
        dist = motifs_thresholds.ScoreDistribution(pssm, background=uniform_bg(), precision=1000)
        t_fnr10 = dist.threshold_fnr(0.10)
        t_fnr20 = dist.threshold_fnr(0.20)
        # Allowing higher FNR should raise the threshold
        self.assertLess(t_fnr10, t_fnr20)

    def test_balanced_close_rates(self):
        pssm = self._pssm_for_thresholds()
        dist = motifs_thresholds.ScoreDistribution(pssm, background=uniform_bg(), precision=1000)
        t_bal, fpr, fnr = dist.threshold_balanced(return_rates=True)
        # Balanced threshold should roughly equalize FPR and FNR
        self.assertLess(abs(fpr - fnr), 0.05)
        # And be between min and max achievable scores
        smin = dist.min_score()
        smax = dist.max_score()
        self.assertGreaterEqual(t_bal, smin)
        self.assertLessEqual(t_bal, smax)

    def test_patser_relation(self):
        # Patser threshold is often defined via information content; here just assert callable & numeric
        pssm = self._pssm_for_thresholds()
        dist = motifs_thresholds.ScoreDistribution(pssm, background=uniform_bg(), precision=1000)
        t_pat = dist.threshold_patser()
        self.assertTrue(isfinite(t_pat))


#  Minimal parser

class TestMinimalParser(TestCase):
    def test_parse_minimal_file_if_present(self):
        # From copying a tiny minimal fixture to week2/data/motifs/minimal_test.meme
        # this will exercise minimal.read() end-to-end. Otherwise it passes.
        root = "week2/data/motifs/minimal_test.meme"
        if os.path.exists(root):
            with open(root, "r") as fh:
                rec = motifs_minimal.read(fh)   # or motifs_init.parse(fh, "minimal") if routing via __init__
            # Basic assertions: version, alphabet, at least 1 motif with expected fields
            self.assertIsNotNone(rec.version)
            self.assertTrue(hasattr(rec, "alphabet"))
            self.assertGreaterEqual(len(rec), 1)
            m0 = rec[0]
            self.assertEqual(m0.length, len(m0.consensus))
        else:
            # No fixture provided yet don't fail the suite
            self.assertTrue(True)
