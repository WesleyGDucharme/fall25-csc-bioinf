#Codon version

GAP_OPEN: int = -5
GAP_EXT: int = -1
NEG_INF: int = -10**12

MATCH: int = 3
MISMATCH: int = -3
GAP: int = -2  # linear gap penalty

def _sub_score(a: str, b: str):
    """Return +3 for match, -3 for mismatch."""
    return MATCH if a == b else MISMATCH

def global_align_linear(q: str, t: str):
    """
    Needleman-Wunsch with linear gap = -2.
    Tie-break order when scores are equal: diag > up > left.
    Returns: (score, aligned_query, aligned_target).
    """
    n: int = len(q)
    m: int = len(t)

    # DP matrix (scores) and pointer matrix (0=diag, 1=up, 2=left, -1=none)
    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]
    ptr = [[-1 for _ in range(m + 1)] for _ in range(n + 1)]

    # Initialization (first row/col use linear gap; pointers reflect direction)
    for i in range(1, n + 1):
        dp[i][0] = i * GAP
        ptr[i][0] = 1  # up
    for j in range(1, m + 1):
        dp[0][j] = j * GAP
        ptr[0][j] = 2  # left

    # Fill
    for i in range(1, n + 1):
        qi: str = q[i - 1]
        dpi_1 = dp[i - 1]   # row i-1
        dpi = dp[i]         # row i
        ptri = ptr[i]
        for j in range(1, m + 1):
            tj: str = t[j - 1]

            diag = dpi_1[j - 1] + _sub_score(qi, tj)
            up = dpi_1[j] + GAP
            left = dpi[j - 1] + GAP

            # Deterministic tie-break: diag > up > left
            best = diag
            d: int = 0  # 0=diag
            if up > best:
                best = up
                d = 1
            # note: use strict '>' so ties keep previous preference
            if left > best:
                best = left
                d = 2

            dpi[j] = best
            ptri[j] = d

    # Traceback
    i: int = n
    j: int = m
    aq = []  # aligned query (reversed)
    at = []  # aligned target (reversed)

    while i > 0 or j > 0:
        d = ptr[i][j] if i >= 0 and j >= 0 else -1
        if d == 0:  # diag
            aq.append(q[i - 1])
            at.append(t[j - 1])
            i -= 1
            j -= 1
        elif d == 1:  # up (gap in target)
            aq.append(q[i - 1])
            at.append("-")
            i -= 1
        elif d == 2:  # left (gap in query)
            aq.append("-")
            at.append(t[j - 1])
            j -= 1
        else:
            # Should only happen at (0,0)
            break

    # Reverse and join
    aq_str = "".join(reversed(aq))
    at_str = "".join(reversed(at))
    return dp[n][m], aq_str, at_str


def local_align_linear(q: str, t: str):
    n: int = len(q)
    m: int = len(t)

    # Score and pointer matrices
    H = [[0 for _ in range(m + 1)] for _ in range(n + 1)]
    ptr = [[-1 for _ in range(m + 1)] for _ in range(n + 1)]  # -1 means stop (score 0)

    best_score: int = 0
    best_i: int = 0
    best_j: int = 0

    for i in range(1, n + 1):
        qi: str = q[i - 1]
        Hi_1 = H[i - 1]
        Hi = H[i]
        ptri = ptr[i]
        for j in range(1, m + 1):
            tj: str = t[j - 1]
            diag = Hi_1[j - 1] + (MATCH if qi == tj else MISMATCH)
            up   = Hi_1[j] + GAP     # gap in target
            left = Hi[j - 1] + GAP   # gap in query

            # Include 0 for local reset; deterministic tie-break among positive candidates
            s = 0
            d = -1  # stop by default
            if diag > s:
                s = diag; d = 0  # diag
            if up > s:
                s = up; d = 1    # up
            if left > s:
                s = left; d = 2  # left

            Hi[j] = s
            ptri[j] = d

            # Track best in row-major order: first max wins
            if s > best_score:
                best_score = s
                best_i = i
                best_j = j

    # Traceback from best_i, best_j until ptr == -1 (score 0)
    i: int = best_i
    j: int = best_j
    aq: List[str] = []
    at: List[str] = []

    while i > 0 and j > 0:
        d = ptr[i][j]
        if d == -1 or H[i][j] == 0:
            break
        if d == 0:         # diag
            aq.append(q[i - 1]); at.append(t[j - 1]); i -= 1; j -= 1
        elif d == 1:       # up: gap in target
            aq.append(q[i - 1]); at.append("-"); i -= 1
        elif d == 2:       # left: gap in query
            aq.append("-"); at.append(t[j - 1]); j -= 1
        else:
            break

    aq_str = "".join(reversed(aq))
    at_str = "".join(reversed(at))
    return best_score, aq_str, at_str

# ---- Global alignment with affine gaps (Gotoh) ----
def global_align_affine(q: str, t: str):
    n: int = len(q)
    m: int = len(t)

    # Score matrices
    M = [[NEG_INF for _ in range(m + 1)] for _ in range(n + 1)]
    X = [[NEG_INF for _ in range(m + 1)] for _ in range(n + 1)]  # gap in target (up move)
    Y = [[NEG_INF for _ in range(m + 1)] for _ in range(n + 1)]  # gap in query  (left move)

    # Backpointers per-state:
    # ptrM: 0=from M diag, 1=from X diag, 2=from Y diag
    # ptrX: 0=from M (open, up), 1=from X (extend, up)
    # ptrY: 0=from M (open, left), 1=from Y (extend, left)
    ptrM = [[-1 for _ in range(m + 1)] for _ in range(n + 1)]
    ptrX = [[-1 for _ in range(m + 1)] for _ in range(n + 1)]
    ptrY = [[-1 for _ in range(m + 1)] for _ in range(n + 1)]

    # Initialization
    M[0][0] = 0
    # First column (j=0): only X is valid (a vertical gap)
    for i in range(1, n + 1):
        # X[i][0] = max(M[i-1][0] + open, X[i-1][0] + ext)
        open_val  = M[i - 1][0] + GAP_OPEN
        extend_val = X[i - 1][0] + GAP_EXT
        if open_val >= extend_val:
            X[i][0] = open_val
            ptrX[i][0] = 0
        else:
            X[i][0] = extend_val
            ptrX[i][0] = 1
        # M[i][0] and Y[i][0] stay NEG_INF

    # First row (i=0): only Y is valid (a horizontal gap)
    for j in range(1, m + 1):
        open_val  = M[0][j - 1] + GAP_OPEN
        extend_val = Y[0][j - 1] + GAP_EXT
        if open_val >= extend_val:
            Y[0][j] = open_val
            ptrY[0][j] = 0
        else:
            Y[0][j] = extend_val
            ptrY[0][j] = 1
        # M[0][j] and X[0][j] stay NEG_INF

    # Fill
    for i in range(1, n + 1):
        qi: str = q[i - 1]
        for j in range(1, m + 1):
            tj: str = t[j - 1]

            # M state (diag move from any state)
            m_from_M = M[i - 1][j - 1] + _sub_score(qi, tj)
            m_from_X = X[i - 1][j - 1] + _sub_score(qi, tj)
            m_from_Y = Y[i - 1][j - 1] + _sub_score(qi, tj)
            bestM: int = m_from_M
            srcM: int = 0
            if m_from_X > bestM:
                bestM = m_from_X; srcM = 1
            if m_from_Y > bestM:
                bestM = m_from_Y; srcM = 2
            M[i][j] = bestM
            ptrM[i][j] = srcM

            # X state (up move: gap in target)
            x_from_M = M[i - 1][j] + GAP_OPEN
            x_from_X = X[i - 1][j] + GAP_EXT
            if x_from_M >= x_from_X:   # prefer open on tie (deterministic)
                X[i][j] = x_from_M; ptrX[i][j] = 0
            else:
                X[i][j] = x_from_X; ptrX[i][j] = 1

            # Y state (left move: gap in query)
            y_from_M = M[i][j - 1] + GAP_OPEN
            y_from_Y = Y[i][j - 1] + GAP_EXT
            if y_from_M >= y_from_Y:   # prefer open on tie
                Y[i][j] = y_from_M; ptrY[i][j] = 0
            else:
                Y[i][j] = y_from_Y; ptrY[i][j] = 1

    # Choose terminal state at (n,m) with diag > up > left tie-break
    state: int = 0  # 0=M (diag), 1=X (up), 2=Y (left)
    best: int = M[n][m]
    if X[n][m] > best:
        state = 1; best = X[n][m]
    if Y[n][m] > best:
        state = 2; best = Y[n][m]

    # Traceback
    i: int = n
    j: int = m
    aq: List[str] = []
    at: List[str] = []

    while i > 0 or j > 0:
        if i == 0 and j > 0:
            state = 2  # must move left
        elif j == 0 and i > 0:
            state = 1  # must move up

        if state == 0:  # M: diag
            src = ptrM[i][j]
            aq.append(q[i - 1]); at.append(t[j - 1])
            i -= 1; j -= 1
            state = src  # 0->M, 1->X, 2->Y
        elif state == 1:  # X: up (gap in target)
            src = ptrX[i][j]
            aq.append(q[i - 1]); at.append("-")
            i -= 1
            state = 0 if src == 0 else 1
        else:  # state == 2, Y: left (gap in query)
            src = ptrY[i][j]
            aq.append("-"); at.append(t[j - 1])
            j -= 1
            state = 0 if src == 0 else 2

    aq_str = "".join(reversed(aq))
    at_str = "".join(reversed(at))
    return best, aq_str, at_str

def fitting_align_affine(q: str, t: str):
    n: int = len(q)
    m: int = len(t)

    # States: M (match/mismatch), X (gap in target, up), Y (gap in query, left)
    M = [[NEG_INF for _ in range(m + 1)] for _ in range(n + 1)]
    X = [[NEG_INF for _ in range(m + 1)] for _ in range(n + 1)]
    Y = [[NEG_INF for _ in range(m + 1)] for _ in range(n + 1)]

    # Backpointers
    ptrM = [[-1 for _ in range(m + 1)] for _ in range(n + 1)]  # 0=M,1=X,2=Y
    ptrX = [[-1 for _ in range(m + 1)] for _ in range(n + 1)]  # 0=from M(open),1=from X(extend)
    ptrY = [[-1 for _ in range(m + 1)] for _ in range(n + 1)]  # 0=from M(open),1=from Y(extend)

    # Initialization for FITTING:
    # Free target prefix â‡’ top row scores are 0 (can start anywhere in target)
    M[0][0] = 0
    for j in range(1, m + 1):
        M[0][j] = 0      # free to "enter" at any target position without penalty
        # X[0][j], Y[0][j] remain NEG_INF

    # First column (j=0): cannot match (M) without target, but can have leading gaps IN TARGET (penalized)
    for i in range(1, n + 1):
        # allow vertical gaps before first target symbol (penalized normally)
        open_val = M[i - 1][0] + GAP_OPEN
        extend_val = X[i - 1][0] + GAP_EXT
        if open_val >= extend_val:
            X[i][0] = open_val; ptrX[i][0] = 0
        else:
            X[i][0] = extend_val; ptrX[i][0] = 1
        # M[i][0], Y[i][0] stay NEG_INF

    # Fill
    for i in range(1, n + 1):
        qi: str = q[i - 1]
        for j in range(1, m + 1):
            tj: str = t[j - 1]

            # M (diag from any state)
            mm = _sub_score(qi, tj)
            m_from_M = M[i - 1][j - 1] + mm
            m_from_X = X[i - 1][j - 1] + mm
            m_from_Y = Y[i - 1][j - 1] + mm
            bestM: int = m_from_M; srcM: int = 0
            if m_from_X > bestM:
                bestM = m_from_X; srcM = 1
            if m_from_Y > bestM:
                bestM = m_from_Y; srcM = 2
            M[i][j] = bestM; ptrM[i][j] = srcM

            # X (up: gap in target)
            x_from_M = M[i - 1][j] + GAP_OPEN
            x_from_X = X[i - 1][j] + GAP_EXT
            if x_from_M >= x_from_X:   # prefer open on tie
                X[i][j] = x_from_M; ptrX[i][j] = 0
            else:
                X[i][j] = x_from_X; ptrX[i][j] = 1

            # Y (left: gap in query)
            y_from_M = M[i][j - 1] + GAP_OPEN
            y_from_Y = Y[i][j - 1] + GAP_EXT
            if y_from_M >= y_from_Y:   # prefer open on tie
                Y[i][j] = y_from_M; ptrY[i][j] = 0
            else:
                Y[i][j] = y_from_Y; ptrY[i][j] = 1

    # Termination for FITTING:
    # Choose best among M/X/Y at row i=n, for ANY column j (free target suffix).
    best_score: int = NEG_INF
    best_state: int = 0  # 0=M,1=X,2=Y
    best_j: int = 0
    i: int = n
    for j in range(0, m + 1):  # left-to-right picks leftmost on tie
        # diag > up > left within the same j
        sM = M[i][j]; sX = X[i][j]; sY = Y[i][j]
        # choose state with our tie-break order
        state_j: int = 0; s_best_j: int = sM
        if sX > s_best_j:
            s_best_j = sX; state_j = 1
        if sY > s_best_j:
            s_best_j = sY; state_j = 2
        # now compare to global best; keep first j on tie
        if s_best_j > best_score:
            best_score = s_best_j; best_state = state_j; best_j = j

    # Traceback from (n, best_j, best_state); stop when i==0 (query fully aligned).
    j: int = best_j
    state: int = best_state
    aq: List[str] = []
    at: List[str] = []

    while i > 0:
        # if j == 0 and we still have i>0, only X (up) is possible
        if j == 0 and state == 2:
            # cannot move left at j==0; force up
            state = 1
        if state == 0:  # M
            src = ptrM[i][j]
            aq.append(q[i - 1]); at.append(t[j - 1])
            i -= 1; j -= 1
            state = src
        elif state == 1:  # X: up (gap in target)
            src = ptrX[i][j]
            aq.append(q[i - 1]); at.append("-")
            i -= 1
            state = 0 if src == 0 else 1
        else:  # state == 2, Y: left (gap in query)
            # If i==0 we would stop (but loop condition prevents), otherwise:
            src = ptrY[i][j]
            aq.append("-"); at.append(t[j - 1])
            j -= 1
            state = 0 if src == 0 else 2

        # Safety: if j < 0 (shouldn't happen), break
        if j < 0:
            break

    aq_str = "".join(reversed(aq))
    at_str = "".join(reversed(at))
    return best_score, aq_str, at_str
