# Copyright 2013 by Michiel de Hoon.  All rights reserved.
#
# This file is part of the Biopython distribution and governed by your
# choice of the "Biopython License Agreement" or the "BSD 3-Clause License".
# Please see the LICENSE file that should have been included as part of this
# package.# Copyright 2013 by Michiel de Hoon.  All rights reserved.
#
# This file is part of the Biopython distribution and governed by your
# choice of the "Biopython License Agreement" or the "BSD 3-Clause License".
# Please see the LICENSE file that should have been included as part of this
# package.

"""Support for various forms of sequence motif matrices.

Implementation of frequency (count) matrices, position-weight matrices,
and position-specific scoring matrices.
"""
from typing import Dict, List, Optional, Tuple
import math


class GenericPositionMatrix:
    alphabet: str
    length: Optional[int]
    _data: Dict[str, List[float]]

    """Base class for the support of position matrix operations."""
    def __init__(self, alphabet, values):
        """Initialize the class."""
        self.alphabet = ''.join(alphabet)  # or keep input order if you wish
        self.length = None
        self._data = {}
        for ch in self.alphabet:
            if self.length is None:
                self.length = len(values[ch])
            elif self.length != len(values[ch]):
                raise Exception("data has inconsistent lengths")
            # ensure Python floats
            row = [float(v) for v in values[ch]]
            self._data[ch] = row

    # indexing helpers
    def _row_labels_from_sel(self, sel) -> List[str]:
        n = len(self.alphabet)
        # slice of rows
        if isinstance(sel, slice):
            start = 0 if sel.start is None else int(sel.start)
            stop  = n if sel.stop is None else int(sel.stop)
            step  = 1 if sel.step is None else int(sel.step)
            if step == 0:
                raise ValueError("slice step cannot be zero")
            if start < 0: start += n
            if stop  < 0: stop  += n
            start = max(0, start); stop = min(n, stop)
            idx = list(range(start, stop, step))
        # explicit index list/tuple
        elif isinstance(sel, (list, tuple)):
            idx = [int(i) for i in sel]
        # single row by letter
        elif isinstance(sel, str):
            try:
                return [self.alphabet[int(sel)]]
            except Exception:
                try:
                    i = self.alphabet.index(sel)
                    return [self.alphabet[i]]
                except Exception:
                    raise KeyError(f"unknown row selector {sel!r}")
        # single row by int-like
        else:
            i = int(sel)
            if i < 0: i += n
            if not (0 <= i < n):
                raise IndexError("row index out of range")
            idx = [i]
        # clamp valid indices and map to letters
        return [self.alphabet[i] for i in idx if 0 <= i < n]

    def _col_list_from_sel(self, sel) -> List[int]:
        m = self.length
        # slice of columns
        if isinstance(sel, slice):
            start = 0 if sel.start is None else int(sel.start)
            stop  = m if sel.stop is None else int(sel.stop)
            step  = 1 if sel.step is None else int(sel.step)
            if step == 0:
                raise ValueError("slice step cannot be zero")
            if start < 0: start += m
            if stop  < 0: stop  += m
            start = max(0, start); stop = min(m, stop)
            return [j for j in range(start, stop, step)]
        # explicit index list/tuple
        if isinstance(sel, (list, tuple)):
            return [int(j) for j in sel]
        # single int-like → return one-element list
        j = int(sel)
        if j < 0: j += m
        if not (0 <= j < m):
            raise IndexError("column index out of range")
        return [j]

    def _take_row_list(self, row: List[float], cols: List[int]) -> List[float]:
        out: List[float] = []
        L = self.length
        for jj in cols:
            j = int(jj)
            if 0 <= j < L:
                out.append(float(row[j]))
        return out

    def _is_slice(self, obj):
        """Duck-type check that works with Codon's Slice[int,int,int]."""
        try:
            name = type(obj).__name__
            # Codon: 'Slice[...]', Python: 'slice'
            return name == "slice" or "Slice" in name
        except:
            return False

    def __getitem__(self, key):
        """
        Support Biopython-style indexing:
          m["A"]                  -> full list of values for row A
          m["A", 3]               -> scalar at row A, column 3
          m[:, 3]                 -> dict {letter: value_at_column_3} for all rows
          m[:, 2:5]               -> sub-matrix (same type) with selected columns
          m["ACG", :]             -> sub-matrix with only these rows
          m[("A","C"), 0:4]       -> sub-matrix with selected rows and column slice
        """
        # 1D: m["A"]
        if isinstance(key, str) and len(key) == 1:
            return list(self._data[key])

        # 2D form
        if isinstance(key, tuple) and len(key) == 2:
            rows, cols = key

            # normalize rows selector

            row_is_slice = (type(rows).__name__ == "slice") or ("Slice" in type(rows).__name__)

            if row_is_slice:
                # counts[:, j] or counts[:, j0:j1] → operate on *all* rows
                row_keys = list(self.alphabet)
            elif isinstance(rows, str) and len(rows) == 1:
                row_keys = [rows]
            elif isinstance(rows, (list, tuple)):
                row_keys = list(rows)
            else:
                # optional: support compact "ACG" string as a list of letters
                if isinstance(rows, str):
                    row_keys = list(rows)
                else:
                    raise KeyError(f"Unsupported row selector {rows!r}")

            # single-column access: decide purely by the TYPE of 'rows'

            # single-column access: decide by the TYPE of 'rows'
            if isinstance(cols, int):
                # (str, int) -> float (single row, single col)
                if isinstance(rows, str):
                    if len(rows) != 1:
                        # multi-letter strings ("ACGT") aren’t allowed for (str, int)
                        # use a list/tuple for multi-row single-column access
                        raise TypeError("Use list/tuple of letters for multi-row single-column access")
                    return float(self._data[rows][cols])

                # (slice, int) -> Dict[str, float]  (e.g. [:, j])
                row_is_slice = (type(rows).__name__ == "slice") or ("Slice" in type(rows).__name__)
                if row_is_slice:
                    return {ch: float(self._data[ch][cols]) for ch in self.alphabet}

                # (list|tuple, int) -> Dict[str, float]
                if isinstance(rows, (list, tuple)):
                    # normalize possible int indices to letters
                    norm = []
                    for r in rows:
                        if isinstance(r, str):
                            norm.append(r)
                        else:
                            idx = int(r)
                            if idx < 0:
                                idx += len(self.alphabet)
                            norm.append(self.alphabet[idx])
                    return {ch: float(self._data[ch][cols]) for ch in norm}

                raise KeyError(f"Unsupported row selector {rows!r} for single-column access")

            # column slice  return a sub-matrix
            if isinstance(cols, slice):
                new_counts = {
                    ch: self._data[ch][cols.start or 0 : cols.stop or self.length]
                    for ch in row_keys
                }
                return GenericPositionMatrix(''.join(row_keys), new_counts)

            raise KeyError(f"Unsupported column selector {cols!r}")

        raise KeyError(f"Cannot understand key {key!r}")

    def get_value(self, letter, i):
        """Return the scalar at row `letter` and column index `i` as float."""
        return float(self._data[letter][i])

    def normalize(self, pseudocounts=None):
        # compatibility shim for Biopython-style API
        # returns a PositionWeightMatrix
        return fpm_normalize(self, pseudocounts)

    def get_row(self, letter):
        """Return a copy of the row for `letter` as a list of floats."""
        return list(self._data[letter])

    def __str__(self):
        """Return a string containing nucleotides and counts of the alphabet in the Matrix."""
        words = [f"{i:6d}" for i in range(self.length)]
        line = "   " + " ".join(words)
        lines = [line]
        for letter in self.alphabet:
            words = [f"{self.get_value(letter, i):6.2f}" for i in range(self.length)]
            line = f"{letter}: " + " ".join(words)
            lines.append(line)
        text = "\n".join(lines) + "\n"
        return text

    @property
    def consensus(self):
        """Return the consensus sequence as a string."""
        if self.length is None or self.length == 0:
            return ""

        out = []
        for i in range(self.length):
            best_ch = self.alphabet[0]
            best_v = float(self._data[best_ch][i])
            for ch in self.alphabet[1:]:
                v = float(self._data[ch][i])
                if v > best_v or (v == best_v and ch < best_ch):
                    best_ch, best_v = ch, v
            out.append(best_ch)
        return "".join(out)

    @property
    def anticonsensus(self):
        """Return the anticonsensus sequence as a string."""
        seq = []
        for i in range(self.length):
            worst_ch = None
            worst = 1e300
            for ch in self.alphabet:
                v = self.get_value(ch, i)
                if v < worst:
                    worst = v
                    worst_ch = ch
            seq.append(worst_ch)
        return ''.join(seq)

    @property
    def degenerate_consensus(self):
        """Return the degenerate consensus sequence as a string."""
        degenerate_nucleotide = {
            "A": "A",
            "C": "C",
            "G": "G",
            "T": "T",
            "U": "U",
            "AC": "M",
            "AG": "R",
            "AT": "W",
            "AU": "W",
            "CG": "S",
            "CT": "Y",
            "CU": "Y",
            "GT": "K",
            "GU": "K",
            "ACG": "V",
            "ACT": "H",
            "ACU": "H",
            "AGT": "D",
            "AGU": "D",
            "CGT": "B",
            "CGU": "B",
            "ACGT": "N",
            "ACGU": "N",
        }
        sequence = ""
        for i in range(self.length):
            # sort letters by column value descending
            nucleotides = sorted(self.alphabet, key=lambda ch: self.get_value(ch, i), reverse=True)
            counts = [self.get_value(c, i) for c in nucleotides]
            if counts[0] > sum(counts[1:]) and counts[0] > 2 * counts[1]:
                key = nucleotides[0]
            elif 4 * sum(counts[:2]) > 3 * sum(counts):
                key = "".join(sorted(nucleotides[:2]))
            elif counts[3] == 0:
                key = "".join(sorted(nucleotides[:3]))
            else:
                key = "ACGT"
            nucleotide = degenerate_nucleotide.get(key, key)
            sequence += nucleotide
        return sequence

    def calculate_consensus(
        self, substitution_matrix=None, plurality=None, identity=0, setcase=None
    ):
        # unchanged logic, returns string
        alphabet = self.alphabet
        if set(alphabet).union("ACGTUN-") == set("ACGTUN-"):
            undefined = "N"
        else:
            undefined = "X"
        if substitution_matrix is None:
            if plurality is not None:
                raise ValueError(
                    "plurality must be None if substitution_matrix is None"
                )
            sequence = ""
            for i in range(self.length):
                maximum = 0
                total = 0
                for letter in alphabet:
                    count = self.get_value(letter, i)
                    total += count
                    if count > maximum:
                        maximum = count
                        consensus_letter = letter
                if maximum < identity * total:
                    consensus_letter = undefined
                else:
                    if setcase is None:
                        setcase_threshold = total / 2
                    else:
                        setcase_threshold = setcase * total
                    if maximum <= setcase_threshold:
                        consensus_letter = consensus_letter.lower()
                sequence += consensus_letter
        else:
            raise NotImplementedError(
                "calculate_consensus currently only supports substitution_matrix=None"
            )
        return sequence

    @property
    def gc_content(self):
        """Compute the fraction GC content."""
        gc_total = 0.0
        total = 0.0
        for i in range(self.length):
            for letter in self.alphabet:
                v = self.get_value(letter, i)
                if letter in "CG":
                    gc_total += v
                total += v
        return gc_total / total if total > 0 else 0.0

    def reverse_complement(self):
        """Compute reverse complement."""
        values: dict[str, list[float]] = {}
        if self.alphabet == "ACGU":
            values["A"] = list(reversed(self.get_row("U")))
            values["U"] = list(reversed(self.get_row("A")))
        else:
            values["A"] = list(reversed(self.get_row("T")))
            values["T"] = list(reversed(self.get_row("A")))
        values["G"] = list(reversed(self.get_row("C")))
        values["C"] = list(reversed(self.get_row("G")))
        return self.__class__(self.alphabet, values)


class PositionSpecificScoringMatrix(GenericPositionMatrix):
    """Class for the support of Position Specific Scoring Matrix calculations."""

    def __init__(self, alphabet, values):
        # values: Dict[str, List[float]] of log-odds
        super().__init__(alphabet, values)

    def calculate(self, sequence):
        """Return the PWM score for a given sequence for all positions."""
        if sorted(self.alphabet) != ["A", "C", "G", "T"]:
            raise ValueError(
                "PSSM has wrong alphabet: %s - Use only with DNA motifs" % self.alphabet
            )
        try:
            s = sequence.decode("ASCII")
        except AttributeError:
            s = str(sequence)
        except Exception:
            raise ValueError("sequence should be a string or bytes-like object") from None

        s = s.upper()
        n = len(s)
        m = self.length
        if n < m:
            return []

        out = []
        letters = ("A", "C", "G", "T")
        for start in range(0, n - m + 1):
            total = 0.0
            bad = False
            for i in range(m):
                ch = s[start + i]
                if ch in letters:
                    total += self.get_value(ch, i)
                else:
                    bad = True
                    break
            out.append(float("nan") if bad else total)
        return out


    def search(self, sequence, threshold=0.0, both=True, chunksize=10**6):
        """Find hits with PWM score above given threshold (generator)."""
        seq = str(sequence).upper()
        seq_len = len(seq)
        motif_l = self.length

        # precompute forward scores by chunks
        def _scan_forward(seq_chunk, offset0):
            scores = self.calculate(seq_chunk)

            for i, sc in enumerate(scores):
                if sc >= threshold:
                    yield offset0 + i, sc

        # reverse complement PSSM if needed
        rc = self.reverse_complement() if both else None

        # chunked scanning
        step = chunksize
        for chunk_start in range(0, seq_len, step):
            end = min(seq_len, chunk_start + step + motif_l - 1)
            subseq = seq[chunk_start:end]

            # forward strand
            for pos, sc in _scan_forward(subseq, chunk_start):
                yield (pos, sc)

            # reverse strand: positions are reported as negative offsets like Biopython
            if both:
                r_scores = rc.calculate(subseq)
                if isinstance(r_scores, float):
                    r_scores = [r_scores]
                for i, sc in enumerate(r_scores):
                    if sc >= threshold:
                        # Biopython yields negative coord = position relative to reverse
                        yield (-(chunk_start + i), sc)

    @property
    def max(self):
        score = 0.0
        for position in range(self.length):
            best = -1e300
            for letter in self.alphabet:
                v = self.get_value(letter, position)
                if v > best:
                    best = v
            score += best
        return score

    @property
    def min(self):
        score = 0.0
        for position in range(self.length):
            worst = 1e300
            for letter in self.alphabet:
                v = self.get_value(letter, position)
                if v < worst:
                    worst = v
            score += worst
        return score

    @property
    def gc_content(self):
        """Compute the GC-ratio."""
        raise Exception("Cannot compute the %GC composition of a PSSM")

    def mean(self, background=None):
        """Return expected value of the score of a motif."""
        if background is None:
            background = dict.fromkeys(self.alphabet, 1.0)
        else:
            background = dict(background)
        total = sum(background.values())
        for letter in self.alphabet:
            background[letter] /= total
        sx = 0.0
        for i in range(self.length):
            for letter in self.alphabet:
                logodds = self.get_value(letter, i)
                if math.isnan(logodds):
                    continue
                if math.isinf(logodds) and logodds < 0:
                    continue
                b = background[letter]
                p = b * math.pow(2, logodds)
                sx += p * logodds
        return sx

    def std(self, background=None):
        """Return standard deviation of the score of a motif."""
        if background is None:
            background = dict.fromkeys(self.alphabet, 1.0)
        else:
            background = dict(background)
        total = sum(background.values())
        for letter in self.alphabet:
            background[letter] /= total
        variance = 0.0
        for i in range(self.length):
            sx = 0.0
            sxx = 0.0
            for letter in self.alphabet:
                logodds = self.get_value(letter, i)
                if math.isnan(logodds):
                    continue
                if math.isinf(logodds) and logodds < 0:
                    continue
                b = background[letter]
                p = b * math.pow(2, logodds)
                sx += p * logodds
                sxx += p * logodds * logodds
            sxx -= sx * sx
            variance += sxx
        variance = max(variance, 0)
        return math.sqrt(variance)

    def dist_pearson(self, other):
        """Return the similarity score based on pearson correlation for the given motif against self.

        We use the Pearson's correlation of the respective probabilities.
        """
        if self.alphabet != other.alphabet:
            raise ValueError("Cannot compare motifs with different alphabets")
        max_p = -2.0
        max_o = 0
        for offset in range(-self.length + 1, other.length):
            if offset < 0:
                p = self.dist_pearson_at(other, -offset)
            else:
                p = other.dist_pearson_at(self, offset)
            if max_p < p:
                max_p = p
                max_o = -offset
        return 1 - max_p, max_o

    def dist_pearson_at(self, other, offset):
        """Return the similarity score based on pearson correlation at the given offset."""
        letters = self.alphabet
        sx = 0.0
        sy = 0.0
        sxx = 0.0
        sxy = 0.0
        syy = 0.0
        norm = max(self.length, offset + other.length) * len(letters)
        for pos in range(min(self.length - offset, other.length)):
            xi = [self.get_value(letter, pos + offset) for letter in letters]
            yi = [other.get_value(letter, pos) for letter in letters]
            sx += sum(xi)
            sy += sum(yi)
            sxx += sum(x * x for x in xi)
            sxy += sum(x * y for x, y in zip(xi, yi))
            syy += sum(y * y for y in yi)
        sx /= norm
        sy /= norm
        sxx /= norm
        sxy /= norm
        syy /= norm
        numerator = sxy - sx * sy
        denominator = math.sqrt((sxx - sx * sx) * (syy - sy * sy))
        return numerator / denominator




    def distribution(self, background=None, precision=10**3):
        """Calculate the distribution of the scores at the given precision."""
        import thresholds  # sibling Codon module
        if background is None:
            background = dict.fromkeys(self.alphabet, 1.0)
        else:
            background = dict(background)
        total = sum(background.values())
        for letter in self.alphabet:
            background[letter] /= total
        return thresholds.ScoreDistribution(precision=precision, pssm=self, background=background)


class PositionWeightMatrix(GenericPositionMatrix):
    """Class for the support of weight calculations on the Position Matrix."""

    def __init__(self, alphabet, counts):
        """Initialize the class."""
        GenericPositionMatrix.__init__(self, alphabet, counts)
        # normalize to probabilities column-wise
        for i in range(self.length):
            total = 0.0
            for letter in alphabet:
                total += float(self.get_value(letter, i))
            if total > 0.0:
                inv = 1.0 / total
                for letter in alphabet:
                    self._data[letter][i] = float(self._data[letter][i]) * inv

    def log_odds(self, background=None):
        """Return the Position-Specific Scoring Matrix.

        The Position-Specific Scoring Matrix (PSSM) contains the log-odds
        scores computed from the probability matrix and the background
        probabilities. If the background is None, a uniform background
        distribution is assumed.
        """
        values = {}
        alphabet = self.alphabet
        if background is None:
            background = dict.fromkeys(self.alphabet, 1.0)
        else:
            background = dict(background)
        total = sum(background.values())
        for letter in alphabet:
            background[letter] /= total
            values[letter] = []
        for i in range(self.length):
            for letter in alphabet:
                b = background[letter]
                if b > 0.0:
                    p = self.get_value(letter, i)
                    if p > 0.0:
                        logodds = math.log(p / b, 2)
                    else:
                        logodds = -math.inf
                else:
                    p = self.get_value(letter, i)
                    if p > 0.0:
                        logodds = math.inf
                    else:
                        logodds = math.nan
                values[letter].append(logodds)
        return PositionSpecificScoringMatrix(alphabet, values)


# Build a frequency-position "matrix" as a GenericPositionMatrix
def make_fpm(alphabet: str, values: Dict[str, List[float]]) -> GenericPositionMatrix:
    # Ensure values are floats & rectangular using your base ctor’s logic
    # (GenericPositionMatrix.__init__ already checks consistency and casts).
    return GenericPositionMatrix(alphabet, values)

# Add pseudocounts and produce a PositionWeightMatrix
def fpm_normalize(fpm: GenericPositionMatrix, pseudocounts=None) -> PositionWeightMatrix:
    # Build per-symbol pseudocounts dict without ever calling float() on a dict
    if pseudocounts is None:
        per = {ch: 0.0 for ch in fpm.alphabet}
    elif isinstance(pseudocounts, (int, float)):
        base = float(pseudocounts)
        per = {ch: base for ch in fpm.alphabet}
    else:
        # Treat as mapping (typed dicts in Codon may not pass isinstance(..., dict))
        try:
            per = {ch: float(pseudocounts[ch]) for ch in fpm.alphabet}
        except Exception:
            raise TypeError(
                "pseudocounts must be None, a number, or a mapping {str: number}"
            )

    counts = {}
    for ch in fpm.alphabet:
        row = fpm._data[ch]
        counts[ch] = [float(v) + per[ch] for v in row]

    return PositionWeightMatrix(fpm.alphabet, counts)
