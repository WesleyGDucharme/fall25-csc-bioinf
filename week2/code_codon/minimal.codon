# Copyright 2018 by Ariel Aptekmann.
# All rights reserved.
#
# This file is part of the Biopython distribution and governed by your
# choice of the "Biopython License Agreement" or the "BSD 3-Clause License".
# Please see the LICENSE file that should have been included as part of this
# package.
"""Module for the support of MEME minimal motif format (Codon port)."""

# Use our local Codon motifs module

from typing import Optional, List, Dict


def read(handle):
    """Parse the text output of the MEME program into a minimal.Record object.

    This function won't retrieve instances, as there are none in minimal meme format.
    """
    from motifs import Motif, Record
    motif_number = 0
    record = Record()

    evalue: Optional[float]
    _read_version(record, handle)
    _read_alphabet(record, handle)
    _read_background(record, handle)

    while True:
        for line in handle:
            if line.startswith("MOTIF"):
                break
        else:
            return record
        name = line.split()[1]
        motif_number += 1
        length, num_occurrences, evalue = _read_motif_statistics(handle)
        counts = _read_lpm(record, handle, length, num_occurrences)
        motif = motifs.Motif(alphabet=record.alphabet, counts=counts)
        motif.background = record.background
        motif.length = motif.counts.length
        motif.num_occurrences = num_occurrences
        motif.evalue = evalue
        motif.name = name
        record.append(motif)
        assert len(record) == motif_number
    # unreachable; loop returns record when stream ends


# Everything below is private

def _read_background(record, handle):
    """Read background letter frequencies (PRIVATE)."""
    for line in handle:
        if line.startswith("Background letter frequencies"):
            background_freqs = []
            for line in handle:
                line = line.rstrip()
                if line:
                    # MEME prints like: "A 0.25 C 0.25 G 0.25 T 0.25"
                    toks = line.split(" ")
                    background_freqs.extend(
                        [float(freq) for i, freq in enumerate(toks) if i % 2 == 1]
                    )
                else:
                    break
            if not background_freqs:
                raise ValueError(
                    "Unexpected end of stream: Expected to find line starting background frequencies."
                )
            break
    else:
        raise ValueError(
            "Improper input file. File should contain a line starting background frequencies."
        )
    record.background = dict(zip(record.alphabet, background_freqs))


def _read_version(record, handle):
    """Read MEME version (PRIVATE)."""
    for line in handle:
        if line.startswith("MEME version"):
            break
    else:
        raise ValueError(
            "Improper input file. File should contain a line starting MEME version."
        )
    ls = line.strip().split()
    record.version = ls[2]


def _read_alphabet(record, handle):
    """Read alphabet (PRIVATE)."""
    for line in handle:
        if line.startswith("ALPHABET"):
            break
    else:
        raise ValueError(
            "Unexpected end of stream: Expected to find line starting with 'ALPHABET'"
        )
    if not line.startswith("ALPHABET= "):
        raise ValueError(f"Line does not start with 'ALPHABET':\n{line}")
    tok = line.strip().replace("ALPHABET= ", "")
    if tok == "ACGT":
        al = "ACGT"
    elif tok == "ACGU":
        al = "ACGU"
    else:
        raise ValueError("Only parsing of DNA and RNA motifs is implemented")
    record.alphabet = al


def _read_lpm(record, handle, length, num_occurrences):
    """Read letter probability matrix (PRIVATE)."""
    counts = [[], [], [], []]
    for line in handle:
        freqs = line.split()
        if len(freqs) != 4:
            break
        # Multiply probabilities by nsites and round to nearest integer
        counts[0].append(int(round(float(freqs[0]) * num_occurrences)))
        counts[1].append(int(round(float(freqs[1]) * num_occurrences)))
        counts[2].append(int(round(float(freqs[2]) * num_occurrences)))
        counts[3].append(int(round(float(freqs[3]) * num_occurrences)))
        if length and len(counts[0]) == length:
            break
    return dict(zip(record.alphabet, counts))


def _read_motif_statistics(handle):
    """Read motif statistics (PRIVATE)."""
    # minimal MEME motif format letter-probability matrix line:
    #   letter-probability matrix: alength= 4 w= 19 nsites= 17 E= 4.1e-009
    for line in handle:
        if line.startswith("letter-probability matrix:"):
            break
    # Defaults per MEME minimal
    num_occurrences = (
        int(line.split("nsites=")[1].split()[0]) if line.find("nsites=") != -1 else 20
    )
    length = int(line.split("w=")[1].split()[0]) if line.find("w=") != -1 else None
    evalue = float(line.split("E=")[1].split()[0]) if line.find("E=") != -1 else 0.0
    return length, num_occurrences, evalue


def _read_motif_name(handle):
    """Read motif name (PRIVATE)."""
    for line in handle:
        if "sorted by position p-value" in line:
            break
    else:
        raise ValueError("Unexpected end of stream: Failed to find motif name")
    words = line.strip().split()
    return " ".join(words[0:2])
