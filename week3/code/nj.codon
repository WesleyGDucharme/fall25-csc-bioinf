# Neighbor-Joining implementation that builds a Tree from an NxN distance matrix.

from tree import Tree, TreeNode

def neighbor_joining(dist):
    """
    dist: list[list[int|float]] symmetric, zero diagonal
    returns: Tree with leaves indexed 0..n-1
    """
    n = len(dist)
    if n == 0:
        raise Exception("Empty distance matrix")
    if any(len(row) != n for row in dist):
        raise Exception("Distance matrix must be square")

    # Cluster IDs: integers. Map each id -> TreeNode for the current cluster.
    nodes = {i: TreeNode(index=i) for i in range(n)}
    active = [i for i in range(n)]

    # Distance matrix keyed by cluster id (float values)
    D = {i: {} for i in active}
    for i in active:
        for j in active:
            if i == j:
                D[i][j] = 0.0
            else:
                D[i][j] = float(dist[i][j])

    next_id = n
    eps = 1e-12

    while len(active) > 3:
        m = len(active)

        # r[i] = sum_k D[i][k]
        r = {i: sum(D[i][k] for k in active if k != i) for i in active}

        # Find pair (i,j) minimizing Q = (m-2)*D[i][j] - r[i] - r[j]
        best_i = active[0]
        best_j = active[1]
        best_Q = (m - 2) * D[best_i][best_j] - r[best_i] - r[best_j]

        for a_idx in range(len(active)):
            i = active[a_idx]
            for b_idx in range(a_idx + 1, len(active)):
                j = active[b_idx]
                Q = (m - 2) * D[i][j] - r[i] - r[j]
                if Q < best_Q:
                    best_Q = Q
                    best_i = i
                    best_j = j

        i, j = best_i, best_j

        # Limb lengths
        delta = (r[i] - r[j]) / (m - 2)
        Li = 0.5 * (D[i][j] + delta)
        Lj = D[i][j] - Li
        if Li < 0 and abs(Li) < eps:
            Li = 0.0
        if Lj < 0 and abs(Lj) < eps:
            Lj = 0.0
        if Li < -eps or Lj < -eps:
            raise Exception("Negative branch length encountered in NJ")

        # New internal node u with children i and j
        u = TreeNode([nodes[i], nodes[j]], [Li, Lj], index=None)
        uid = next_id
        next_id += 1
        nodes[uid] = u

        # Distances from u to all other clusters k
        D[uid] = {}
        for k in active:
            if k == i or k == j:
                continue
            Duk = 0.5 * (D[i][k] + D[j][k] - D[i][j])
            if Duk < 0 and abs(Duk) < eps:
                Duk = 0.0
            D[uid][k] = Duk

        # Insert symmetric entries
        for k in active:
            if k == i or k == j:
                continue
            D[k][uid] = D[uid][k]

        # Remove i and j from D
        for k in list(D.keys()):
            if k == i or k == j:
                continue
            if i in D[k]:
                del D[k][i]
            if j in D[k]:
                del D[k][j]
        if i in D:
            del D[i]
        if j in D:
            del D[j]

        # Update active set: drop i,j; add uid
        active = [k for k in active if k != i and k != j]
        active.append(uid)

    # Final join of the last three clusters
    i, j, k = active[0], active[1], active[2]

    def Dget(a, b):
        if a in D and b in D[a]:
            return D[a][b]
        return D[b][a]

    Dij = Dget(i, j)
    Dik = Dget(i, k)
    Djk = Dget(j, k)

    # Pendant lengths for a 3-way root
    Li = 0.5 * (Dij + Dik - Djk)
    Lj = 0.5 * (Dij + Djk - Dik)
    Lk = 0.5 * (Dik + Djk - Dij)

    # Clamp tiny negative noise
    if abs(Li) < eps: Li = 0.0
    if abs(Lj) < eps: Lj = 0.0
    if abs(Lk) < eps: Lk = 0.0

    root = TreeNode([nodes[i], nodes[j], nodes[k]], [Li, Lj, Lk], index=None)
    return Tree(root)
