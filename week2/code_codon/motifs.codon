# Copyright 2003-2009 by Bartek Wilczynski.  All rights reserved.
# Copyright 2012-2013 by Michiel JL de Hoon.  All rights reserved.
# Revisions copyright 2019 by Victor Lin.  All rights reserved.
#
# This file is part of the Biopython distribution and governed by your
# choice of the "Biopython License Agreement" or the "BSD 3-Clause License".
# Please see the LICENSE file that should have been included as part of this
# package.

"""Tools for sequence motif analysis.

Bio.motifs contains the core Motif class containing various I/O methods
as well as methods for motif comparisons and motif searching in sequences.
It also includes functionality for parsing output from the AlignACE, MEME,
and MAST programs, as well as files in the TRANSFAC format.
"""

import math
import matrix
import minimal

def _counts_from_instances(instances, alphabet):
    # Normalize & validate alphabet
    if alphabet is None:
        alphabet = "ACGT"
    alpha = str(alphabet).upper()
    if not alpha:
        raise ValueError("Alphabet must contain at least one symbol")

    # Build ASCII LUT: map byte -> index in alphabet, -1 means ignore
    # (Use a fixed-size list for speed; no hashing in the inner loop.)
    lut = [-1] * 256
    letters = []  # preserve actual letters for output keys
    seen = set()
    for i in range(len(alpha)):
        ch = alpha[i]
        # skip duplicates; ensure single ASCII letter
        if (ch not in seen) and isinstance(ch, str) and len(ch) == 1:
            b = ord(ch)
            if 0 <= b < 256:
                lut[b] = len(letters)
                letters.append(ch)
                seen.add(ch)
    if not letters:
        raise ValueError("Alphabet must contain at least one valid ASCII symbol")

    # Normalize instances -> ASCII uppercase codepoints (ints), filter empties/non-ASCII
    norm_codes = []
    for s in instances:
        if s is None:
            continue
        try:
            ss = str(s)
        except Exception:
            continue
        if not ss:
            continue

        # Convert to uppercase ASCII in one pass; skip non-ASCII sequences
        ok = True
        codes = [0] * len(ss)
        for i in range(len(ss)):
            c = ord(ss[i])
            if c > 127:
                ok = False  # non-ASCII; skip this instance
                break
            if 97 <= c <= 122:   # 'a'..'z'
                c -= 32          # to 'A'..'Z'
            codes[i] = c
        if ok:
            norm_codes.append(codes)

    if not norm_codes:
        raise ValueError("No instances provided")

    # Enforce equal length
    L = len(norm_codes[0])
    for cs in norm_codes:
        if len(cs) != L:
            raise ValueError("All instances must have the same length")

    # Prepare counts: list-of-lists for speed; convert to dict at the end
    K = len(letters)
    counts_ll = []
    for _ in range(K):
        counts_ll.append([0] * L)

    # Count using LUT (no dict access in the hot loop)
    for cs in norm_codes:
        # bs is ASCII-uppercase bytes
        for i in range(L):
            b = cs[i]
            idx = lut[b]
            if idx >= 0:
                counts_ll[idx][i] += 1
            # else: skip

    # Convert to dict[str, List[int]] once (outside hot loop)
    counts = {}
    for idx in range(K):
        counts[letters[idx]] = counts_ll[idx]

    return counts, L

def create(instances, alphabet: str = "ACGT"):
    """Create a Motif object from a list of sequence strings."""
    counts, _ = _counts_from_instances(instances, alphabet)
    return Motif(alphabet=alphabet, counts=counts)


def parse(handle, fmt, strict=True):
    """Parse an output file from a motif finding program (Codon port).

    Supported here:
      - "minimal": MINIMAL MEME output file motif (delegates to our Codon minimal.read)

    Other formats are out of scope for these ported modules and will raise.
    """
    f = fmt.lower()
    if f == "minimal":
        # Use the local Codon minimal parser
        return minimal.read(handle)
    # Everything else (AlignAce, MEME, MAST, TRANSFAC, pfm*, jaspar, sites, xms) will raise an error
    raise ValueError(f"Unknown or unsupported format for this Codon ports: {fmt}")

def read(handle, fmt, strict=True):
    """Read a motif from a handle using the specified file-format.

    This supports the same formats as Bio.motifs.parse(), but
    only for files containing exactly one motif.  For example,
    reading a JASPAR-style pfm file:

    >>> from Bio import motifs
    >>> with open("motifs/SRF.pfm") as handle:
    ...     m = motifs.read(handle, "pfm")
    >>> m.consensus
    Seq('GCCCATATATGG')

    Or a single-motif MEME file,

    >>> from Bio import motifs
    >>> with open("motifs/meme.psp_test.classic.zoops.xml") as handle:
    ...     m = motifs.read(handle, "meme")
    >>> m.consensus
    Seq('GCTTATGTAA')

    If the handle contains no records, or more than one record,
    an exception is raised:

    >>> from Bio import motifs
    >>> with open("motifs/alignace.out") as handle:
    ...     motif = motifs.read(handle, "AlignAce")
    Traceback (most recent call last):
        ...
    ValueError: More than one motif found in handle

    If however you want the first motif from a file containing
    multiple motifs this function would raise an exception (as
    shown in the example above).  Instead use:

    >>> from Bio import motifs
    >>> with open("motifs/alignace.out") as handle:
    ...     record = motifs.parse(handle, "alignace")
    >>> motif = record[0]
    >>> motif.consensus
    Seq('TCTACGATTGAG')

    Use the Bio.motifs.parse(handle, fmt) function if you want
    to read multiple records from the handle.

    If strict is True (default), the parser will raise a ValueError if the
    file contents does not strictly comply with the specified file format.
    """
    fmt = fmt.lower()
    motifs = parse(handle, fmt, strict)
    if len(motifs) == 0:
        raise ValueError("No motifs found in handle")
    if len(motifs) > 1:
        raise ValueError("More than one motif found in handle")
    motif = motifs[0]
    return motif


class Motif:
    """A class representing sequence motifs."""

    def __init__(self, alphabet="ACGT", alignment=None, counts=None):
        """Initialize the class."""
        self.name = ""

        if counts is not None and alignment is not None:
            raise Exception(
                ValueError, "Specify either counts or an alignment, don't specify both"
            )

        if alignment is not None:
            # Alignment-based construction is out of scope for this port.
            raise NotImplementedError("Alignment-based Motif init is not supported in Codon port")

        if counts is not None:
            self.alignment = None
            float_counts = {ch: [float(v) for v in row] for ch, row in counts.items()}
            self.counts = matrix.FrequencyPositionMatrix(alphabet, float_counts)
            self.length = self.counts.length
        else:
            self.counts = None
            self.alignment = None
            self.length = None

        self.alphabet = alphabet
        self.pseudocounts = None
        self.background = None
        self.mask = None

    # mask property
    @property
    def mask(self):
        return self.__mask

    @mask.setter
    def mask(self, mask):
        if self.length is None:
            self.__mask = ()
        elif mask is None:
            self.__mask = (1,) * self.length
        elif len(mask) != self.length:
            raise ValueError(
                "The length (%d) of the mask is inconsistent with the length (%d) of the motif"
                % (len(mask), self.length),
            )
        elif isinstance(mask, str):
            tmp = []
            for char in mask:
                if char == "*":
                    tmp.append(1)
                elif char == " ":
                    tmp.append(0)
                else:
                    raise ValueError(
                        "Mask should contain only '*' or ' ' and not a '%s'" % char
                    )
            self.__mask = tuple(tmp)
        else:
            self.__mask = tuple(int(bool(c)) for c in mask)

    # pseudocounts property
    @property
    def pseudocounts(self):
        return self._pseudocounts

    @pseudocounts.setter
    def pseudocounts(self, value):
        if isinstance(value, dict):
            self._pseudocounts = {letter: value[letter] for letter in self.alphabet}
        else:
            if value is None:
                value = 0.0
            self._pseudocounts = dict.fromkeys(self.alphabet, value)

    # background property
    @property
    def background(self):
        return self._background

    @background.setter
    def background(self, value):
        if isinstance(value, dict):
            self._background = {letter: value[letter] for letter in self.alphabet}
        elif value is None:
            self._background = dict.fromkeys(self.alphabet, 1.0)
        else:
            if not self._has_dna_alphabet() and not self._has_rna_alphabet():
                raise ValueError(
                    "Setting the background to a single value only works for DNA and RNA "
                    "motifs (in which case the value is interpreted as the GC content)"
                )
            T_or_U = "T" if self._has_dna_alphabet() else "U"
            bg = {}
            bg["A"] = (1.0 - value) / 2.0
            bg["C"] = value / 2.0
            bg["G"] = value / 2.0
            bg[T_or_U] = (1.0 - value) / 2.0
            self._background = bg
        total = sum(self._background.values())
        for letter in self.alphabet:
            self._background[letter] /= total

    def __getitem__(self, key):
        """Return a new Motif object for the positions included in key.

        >>> from Bio import motifs
        >>> motif = motifs.create(["AACGCCA", "ACCGCCC", "AACTCCG"])
        >>> print(motif)
        AACGCCA
        ACCGCCC
        AACTCCG
        >>> print(motif[:-1])
        AACGCC
        ACCGCC
        AACTCC
        """
        if not isinstance(key, slice):
            raise TypeError("motif indices must be slices")
        alphabet = self.alphabet
        if self.alignment is None:
            alignment = None
            if self.counts is None:
                counts = None
            else:
                counts = {letter: self.counts[letter][key] for letter in alphabet}
        else:
            alignment = self.alignment[:, key]
            counts = None
        motif = Motif(alphabet=alphabet, alignment=alignment, counts=counts)
        motif.mask = self.mask[key]
        if alignment is None and counts is None:
            try:
                length = self.length
            except AttributeError:
                pass
            else:
                motif.length = len(range(*key.indices(length)))
        motif.pseudocounts = self.pseudocounts.copy()
        motif.background = self.background.copy()
        return motif

    @property
    def pwm(self):
        """Calculate and return the position weight matrix for this motif."""
        return self.counts.normalize(self._pseudocounts)

    @property
    def pssm(self):
        """Calculate and return the position specific scoring matrix for this motif."""
        return self.pwm.log_odds(self._background)

    def __str__(self, masked=False):
        """Return string representation of a motif."""
        text = ""
        if self.alignment is not None:
            text += "\n".join(self.alignment)

        if masked:
            for i in range(self.length):
                if self.__mask[i]:
                    text += "*"
                else:
                    text += " "
            text += "\n"
        return text

    def __len__(self):
        """Return the length of a motif.

        Please use this method (i.e. invoke len(m)) instead of referring to m.length directly.
        """
        if self.length is None:
            return 0
        else:
            return self.length

    def _has_dna_alphabet(self):
        return sorted(self.alphabet) == ["A", "C", "G", "T"]

    def _has_rna_alphabet(self):
        return sorted(self.alphabet) == ["A", "C", "G", "U"]

    def reverse_complement(self):
        """Return the reverse complement of the motif as a new motif."""
        alphabet = self.alphabet
        if not self._has_dna_alphabet() and not self._has_rna_alphabet():
            raise ValueError(
                "Calculating reverse complement only works for DNA and RNA motifs"
            )
        T_or_U = "T" if self._has_dna_alphabet() else "U"
        if self.alignment is not None:
            alignment = self.alignment.reverse_complement()
            if T_or_U == "U":
                alignment.sequences = [s.replace("T", "U") for s in alignment.sequences]
            res = Motif(alphabet=alphabet, alignment=alignment)
        else:  # has counts
            counts = {
                "A": self.counts[T_or_U][::-1],
                "C": self.counts["G"][::-1],
                "G": self.counts["C"][::-1],
                T_or_U: self.counts["A"][::-1],
            }
            res = Motif(alphabet=alphabet, counts=counts)
        res.__mask = self.__mask[::-1]
        res.background = {
            "A": self.background[T_or_U],
            "C": self.background["G"],
            "G": self.background["C"],
            T_or_U: self.background["A"],
        }
        res.pseudocounts = {
            "A": self.pseudocounts[T_or_U],
            "C": self.pseudocounts["G"],
            "G": self.pseudocounts["C"],
            T_or_U: self.pseudocounts["A"],
        }
        return res

    @property
    def consensus(self):
        """Return the consensus sequence."""
        return self.counts.consensus

    @property
    def anticonsensus(self):
        """Return the least probable pattern to be generated from this motif."""
        return self.counts.anticonsensus

    @property
    def degenerate_consensus(self):
        """Return the degenerate consensus sequence.

        Following the rules adapted from
        D. R. Cavener: "Comparison of the consensus sequence flanking
        translational start sites in Drosophila and vertebrates."
        Nucleic Acids Research 15(4): 1353-1361. (1987).

        The same rules are used by TRANSFAC.
        """
        return self.counts.degenerate_consensus

    @property
    def relative_entropy(self):
        """Return an array with the relative entropy for each column of the motif."""
        background = self.background
        pseudocounts = self.pseudocounts
        alphabet = self.alphabet
        counts = self.counts
        length = self.length

        values = [0.0] * (length if length else 0)
        if length is None or counts is None:
            return values

        # Compute per-column totals (counts + pseudocounts)
        totals = []
        for i in range(length):
            col_total = 0.0
            for c in alphabet:
                col_total += counts[c][i] + pseudocounts[c]
            totals.append(col_total)

        # Compute sum over letters: p * log2(p / bg)
        for i in range(length):
            if totals[i] <= 0:
                continue
            for letter in alphabet:
                freq = counts[letter][i] + pseudocounts[letter]
                if freq <= 0:
                    continue
                p = freq / totals[i]
                bg = background[letter]
                # If bg is 0, skip (consistent with log-odds handling in other functions)
                if bg <= 0:
                    continue
                values[i] += p * (math.log(p / bg, 2))
        return values

    def weblogo(self, fname, fmt="PNG", version=None, **kwds):
        """Not implemented in Codon port (networked WebLogo)."""
        raise NotImplementedError("weblogo() is unsupported in Codon port")

    def __format__(self, format_spec, **kwargs):
        """Formatting not implemented in Codon ported modules."""
        f = (format_spec or "").lower()
        if not f:
            return str(self)

        if self.counts is None or self.length is None:
            raise ValueError("No counts available to format")

        # Helper to format one row of floats like "  1.00   0.00 ..."
        def _fmt_row(vals):
            return " ".join("%6.2f" % float(v) for v in vals)

        if f == "pfm":
            # Four lines (in self.alphabet order), no row labels, trailing newline.
            lines = []
            for letter in self.alphabet:
                row = [self.counts.get_value(letter, i) for i in range(self.length)]
                lines.append(_fmt_row(row))
            return "\n".join(lines) + "\n"

        if f == "jaspar":
            # Header: ><id> <name>  (id is None in your tests)
            header = f">{self.__dict__.get('accession', None)} {self.name}".rstrip()
            lines = [header]
            for letter in self.alphabet:
                row = [self.counts.get_value(letter, i) for i in range(self.length)]
                lines.append(f"{letter} [ {_fmt_row(row)}]")
            return "\n".join(lines) + "\n"

        if f == "transfac":
            # Header
            lines = ["P0      " + "      ".join(self.alphabet)]
            # Body: index 01..N with integer counts and consensus letter at end
            for i in range(self.length):
                # counts per column in alphabet order
                col_vals = [self.counts.get_value(letter, i) for letter in self.alphabet]
                ints = [str(int(round(v))) for v in col_vals]
                # consensus = letter with max count; ties pick first by order
                max_idx = max(range(len(col_vals)), key=lambda k: col_vals[k])
                consensus = self.alphabet[max_idx]
                lines.append(f"{i+1:02d}      " + "      ".join(ints) + f"      {consensus}")
            lines += ["XX", "//"]
            return "\n".join(lines) + "\n"

        raise ValueError(f"Unknown motif format: {format_spec!r}")

    def format(self, format_spec):
        return self.__format__(format_spec)

def write(motifs, fmt, **kwargs):
    """Not implemented in Codon port."""
    raise NotImplementedError("write() unsupported in Codon port")

