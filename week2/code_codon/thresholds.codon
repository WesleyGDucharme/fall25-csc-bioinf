# Copyright 2008 by Norbert Dojer.  All rights reserved.
# Adapted by Bartek Wilczynski.
# This code is part of the Biopython distribution and governed by its
# license.  Please see the LICENSE file that should have been included
# as part of this package.
"""Approximate calculation of appropriate thresholds for motif finding."""

class ScoreDistribution:
    """Approximate score distribution for a given PWM/PSSM.

    Uses dynamic programming with a fixed precision grid to approximate
    motif and background score densities, and exposes threshold helpers.
    """

    def __init__(self, motif=None, precision: int = 10**3, pssm=None, background=None):
        """Initialize the class.

        Preferred use (matches your tests):
            ScoreDistribution(pssm=pssm, background={...}, precision=1000)
        """
        # If caller passed a motif, convert it to a PSSM path so we only
        # maintain one implementation path (safer for Codon).
        if pssm is None and motif is not None:
            # Expect motif to have pwm + background
            pwm = motif.pwm  # property
            pssm = pwm.log_odds(motif.background)
            background = motif.background

        if pssm is None:
            raise ValueError("ScoreDistribution requires either a pssm or a motif")

        # PSSM-based initialization (matches Biopython semantics)
        # pssm.min / pssm.max / pssm.length / pssm.mean(background) should be provided
        self.min_score: float = min(0.0, pssm.min)
        self.interval: float = max(0.0, pssm.max) - self.min_score
        self.n_points: int = precision * pssm.length
        self.ic: float = pssm.mean(background)  # information content proxy

        # Guard against degenerate grids (avoid division by zero)
        if self.n_points < 2:
            self.n_points = 2
        if self.interval <= 0.0:
            # Almost-constant scores: make a tiny positive interval to keep math stable
            self.interval = 1e-12

        self.step: float = self.interval / (self.n_points - 1)

        self.mo_density = [0.0] * self.n_points
        self.bg_density = [0.0] * self.n_points
        self.mo_density[-self._index_diff(self.min_score)] = 1.0
        self.bg_density[-self._index_diff(self.min_score)] = 1.0

        # Convolve position by position
        for position in range(pssm.length):
            mo_new = [0.0] * self.n_points
            bg_new = [0.0] * self.n_points
            # column dict of letter->score
            lo = pssm[:, position]
            for letter, score in lo.items():
                bg = background[letter]
                mo = (2 ** pssm[letter, position]) * bg
                d = self._index_diff(score)
                for i in range(self.n_points):
                    j = self._add(i, d)
                    mo_new[j] += self.mo_density[i] * mo
                    bg_new[j] += self.bg_density[i] * bg
            self.mo_density = mo_new
            self.bg_density = bg_new

    def _index_diff(self, x: float, y: float = 0.0) -> int:
        # Round-to-nearest index shift
        return int((x - y + 0.5 * self.step) // self.step)

    def _add(self, i: int, j: int) -> int:
        # Clamp to [0, n_points-1]
        s = i + j
        if s < 0:
            return 0
        if s >= self.n_points:
            return self.n_points - 1
        return s

    def modify(self, scores, mo_probs, bg_probs):
        """Modify motif and background density by convolving a new column.

        `scores` : dict(letter -> log-odds score)
        `mo_probs`: dict(letter -> motif emission prob at this position)
        `bg_probs`: dict(letter -> background prob)
        """
        mo_new = [0.0] * self.n_points
        bg_new = [0.0] * self.n_points
        for k, v in scores.items():
            d = self._index_diff(v)
            for i in range(self.n_points):
                j = self._add(i, d)
                mo_new[j] += self.mo_density[i] * mo_probs[k]
                bg_new[j] += self.bg_density[i] * bg_probs[k]
        self.mo_density = mo_new
        self.bg_density = bg_new

    def threshold_fpr(self, fpr: float) -> float:
        """Threshold giving the desired false positive rate (type I error)."""
        i = self.n_points
        prob = 0.0
        while prob < fpr and i > 0:
            i -= 1
            prob += self.bg_density[i]
        return self.min_score + i * self.step

    def threshold_fnr(self, fnr: float) -> float:
        """Threshold giving the desired false negative rate (type II error)."""
        i = -1
        prob = 0.0
        while prob < fnr and i < self.n_points - 1:
            i += 1
            prob += self.mo_density[i]
        return self.min_score + i * self.step

    def threshold_balanced(self, rate_proportion: float = 1.0, return_rate: bool = False):
        """Threshold where FNR == rate_proportion * FPR.

        If `return_rate` is True, also return the FPR at that threshold.
        """
        i = self.n_points
        fpr = 0.0
        fnr = 1.0
        while fpr * rate_proportion < fnr and i > 0:
            i -= 1
            fpr += self.bg_density[i]
            fnr -= self.mo_density[i]
        t = self.min_score + i * self.step
        if return_rate:
            return t, fpr
        return t

    def threshold_patser(self) -> float:
        """Patser-like threshold: solve log2(FPR) = -IC(M)."""
        return self.threshold_fpr(fpr=(2 ** (-self.ic)))

